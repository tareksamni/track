// Tideland Go Application Support - Errors
//
// Copyright (C) 2013-2014 Frank Mueller / Oldenburg / Germany
//
// All rights reserved. Use of this source code is governed
// by the new BSD license.

package errors

//--------------------
// IMPORTS
//--------------------

import (
	"fmt"
	"path"
	"runtime"
)

//--------------------
// CONSTANTS
//--------------------

const (
	ecNoError = iota
	ecInvalidErrorType

	msgInvalidErrorType = "invalid error type: %T %q"
)

//--------------------
// ERROR
//--------------------

// errorBox encapsulates an error.
type errorBox struct {
	err      error
	code     int
	msg      string
	fileName string
	line     int
}

// newErrorBox creates an initialized error box.
func newErrorBox(err error, code int, format string, args ...interface{}) *errorBox {
	_, file, line, _ := runtime.Caller(2)
	_, fileName := path.Split(file)
	return &errorBox{
		err:      err,
		code:     code,
		msg:      fmt.Sprintf(format, args...),
		fileName: fileName,
		line:     line,
	}
}

// Error returns the error as string.
func (e *errorBox) Error() string {
	if e.err != nil {
		return fmt.Sprintf("[E%03d] %s: %v", e.code, e.msg, e.err)
	}
	return fmt.Sprintf("[E%03d] %s", e.code, e.msg)
}

// Annotate creates an error wrapping another one together with a
// a code, a message and message arguments.
func Annotate(err error, code int, format string, args ...interface{}) error {
	return newErrorBox(err, code, format, args...)
}

// New creates an error with the given code, message and arguments.
func New(code int, format string, args ...interface{}) error {
	return newErrorBox(nil, code, format, args...)
}

// Valid returns true if it is a valid error generated by
// this package.
func Valid(err error) bool {
	_, ok := err.(*errorBox)
	return ok
}

// IsError checks if an error is one created by this
// package and has the passed code
func IsError(err error, code int) bool {
	if e, ok := err.(*errorBox); ok {
		return e.code == code
	}
	return false
}

// Annotated returns the possibly annotated error. In case of
// a different error an invalid type error is returned.
func Annotated(err error) error {
	if e, ok := err.(*errorBox); ok {
		return e.err
	}
	return New(ecInvalidErrorType, msgInvalidErrorType, err, err)
}

// Location returns the file name and the line of the error.
func Location(err error) (string, int, error) {
	if e, ok := err.(*errorBox); ok {
		return e.fileName, e.line, nil
	}
	return "", 0, New(ecInvalidErrorType, msgInvalidErrorType, err, err)
}

// Stack returns a slice of errors down to the first
// non-errors error.
func Stack(err error) []error {
	if e, ok := err.(*errorBox); ok {
		return append([]error{e}, Stack(e.err)...)
	}
	return []error{err}
}

// IsInvalidTypeError checks if an error signals an invalid
// type in case of testing for an annotated error.
func IsInvalidTypeError(err error) bool {
	return IsError(err, ecInvalidErrorType)
}

// EOF
