// Tideland Go Application Support - Errors
//
// Copyright (C) 2013-2014 Frank Mueller / Tideland / Oldenburg / Germany
//
// All rights reserved. Use of this source code is governed
// by the new BSD license.

package errors

//--------------------
// IMPORTS
//--------------------

import (
	"fmt"
	"path"
	"runtime"
)

//--------------------
// MESSAGES
//--------------------

// Messages contains the message strings for the the error codes.
type Messages map[int]string

// Format returns the formatted error message for code with the
// given arguments.
func (m Messages) Format(code int, args ...interface{}) string {
	if m == nil || m[code] == "" {
		if len(args) == 0 {
			return fmt.Sprintf("[E999] invalid error code '%d'")
		}
		format := fmt.Sprintf("%v", args[0])
		return fmt.Sprintf(format, args[1:]...)
	}
	format := m[code]
	return fmt.Sprintf(format, args...)
}

//--------------------
// CONSTANTS
//--------------------

const (
	ErrInvalidErrorType = iota + 1
)

var messages = Messages{
	ErrInvalidErrorType: "invalid error type: %T %q",
}

//--------------------
// ERROR
//--------------------

// errorBox encapsulates an error.
type errorBox struct {
	err      error
	code     int
	msg      string
	fileName string
	line     int
}

// newErrorBox creates an initialized error box.
func newErrorBox(err error, code int, msgs Messages, args ...interface{}) *errorBox {
	_, file, line, _ := runtime.Caller(2)
	_, fileName := path.Split(file)
	return &errorBox{
		err:      err,
		code:     code,
		msg:      msgs.Format(code, args...),
		fileName: fileName,
		line:     line,
	}
}

// Error returns the error as string.
func (e *errorBox) Error() string {
	if e.err != nil {
		return fmt.Sprintf("[E%03d] %s: %v", e.code, e.msg, e.err)
	}
	return fmt.Sprintf("[E%03d] %s", e.code, e.msg)
}

// Annotate creates an error wrapping another one together with a
// a code.
func Annotate(err error, code int, msgs Messages, args ...interface{}) error {
	return newErrorBox(err, code, msgs, args...)
}

// New creates an error with the given code.
func New(code int, msgs Messages, args ...interface{}) error {
	return newErrorBox(nil, code, msgs, args...)
}

// Valid returns true if it is a valid error generated by
// this package.
func Valid(err error) bool {
	_, ok := err.(*errorBox)
	return ok
}

// IsError checks if an error is one created by this
// package and has the passed code
func IsError(err error, code int) bool {
	if e, ok := err.(*errorBox); ok {
		return e.code == code
	}
	return false
}

// Annotated returns the possibly annotated error. In case of
// a different error an invalid type error is returned.
func Annotated(err error) error {
	if e, ok := err.(*errorBox); ok {
		return e.err
	}
	return New(ErrInvalidErrorType, messages, err, err)
}

// Location returns the file name and the line of the error.
func Location(err error) (string, int, error) {
	if e, ok := err.(*errorBox); ok {
		return e.fileName, e.line, nil
	}
	return "", 0, New(ErrInvalidErrorType, messages, err, err)
}

// Stack returns a slice of errors down to the first
// non-errors error.
func Stack(err error) []error {
	if e, ok := err.(*errorBox); ok {
		return append([]error{e}, Stack(e.err)...)
	}
	return []error{err}
}

// IsInvalidTypeError checks if an error signals an invalid
// type in case of testing for an annotated error.
func IsInvalidTypeError(err error) bool {
	return IsError(err, ErrInvalidErrorType)
}

// EOF
